<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[sofency]]></title>
    <url>%2F2019%2F03%2F07%2Fsofency%2F</url>
    <content type="text"><![CDATA[sofencymy first blog这个是三级标题 列表1 列表2 a 子列表1 b 子列表2 列表3 你是谁 sofency123456#include &lt;stdio.h&gt;int mian()&#123; printf("hello world"); return 0;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>摸索</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表实现快速排列]]></title>
    <url>%2F2019%2F03%2F07%2F%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[本篇博客主要讲解如何使用单链表进行快速排列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct list//构建结构体&#123; int data; struct list*next;&#125;LIST,*PLIST;PLIST init()//结构体的初始化&#123; PLIST temp; temp = (PLIST)malloc(sizeof(LIST)); temp-&gt;next = NULL; return temp;&#125;void insert(PLIST head, int NewDate)//数据的插入&#123; //头插法 PLIST p= (PLIST)malloc(sizeof(LIST));//准备新结点 p-&gt;data = NewDate; //数据放进去#if 0 temp-&gt;next = head-&gt;next;//将head后面的连接到temp-&gt;next上面。同时head断了与后面的连接 head-&gt;next = temp;//将temp连接到head-&gt;next上连接起来#else //尾插法 PLIST temp = head;//head赋值给temp while (temp-&gt;next != NULL)//遍历head找到尾部 &#123; temp = temp-&gt;next; &#125; //找到了 就退出开始插入。 temp-&gt;next = p;//刚刚申请的结点 p-&gt;next = NULL;#endif&#125;void ScanData(PLIST head)&#123; printf("请输入数字\n"); for (int i = 0; i &lt; 5; i++) &#123; int n = 0; printf("&gt;"); scanf("%d", &amp;n); insert(head, n); &#125;&#125;void print(PLIST head)&#123; PLIST p = head-&gt;next; while (p!= NULL) &#123; printf("%d\t", p-&gt;data); p = p-&gt;next; &#125;&#125;void Sort(PLIST *head)//功能函数&#123; PLIST p, q;//定义指针 q = (*head)-&gt;next;//工作指针 p = (*head)-&gt;next;//基准 while (q-&gt;next != NULL) &#123; if (p-&gt;next-&gt;data &lt; p-&gt;data)//找到比基准小的数字 &#123; q = p-&gt;next;//将小于基准的位置找出来 p-&gt;next = p-&gt;next-&gt;next;//将该数字前后连起来 q-&gt;next = p; (*head)-&gt;next = q;//查到基准的前面 &#125; else &#123; p-&gt;next = p-&gt;next-&gt;next; &#125; q = q-&gt;next; &#125;&#125;int main()&#123; PLIST head; head = init(); ScanData(head); //print(head); Sort(&amp;head); print(head); getchar(); return 0;&#125;]]></content>
  </entry>
</search>
