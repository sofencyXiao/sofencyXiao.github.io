<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式的基本用法12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; const char *str; char str1[20]; char str2[20]; char str3[20]; char str4[20]; str="my home is China"; sscanf(str,"%s %s %s %s",str1,str2,str3,str4); printf("%s\n",str); printf("%s %s\n%s %s\n",str1,str2,str3,str4); //显示str1=my str2=home str3=is str4=china str="012abcABC---"; sscanf(str,"%[0-9]%[a-z]%[A-Z]%s",str1,str2,str3,str4); printf("%s\n",str); printf("%s %s\n%s %s\n",str1,str2,str3,str4); //str1=012 str2=abc str3=ABC str4=--- str="123.456,789"; sscanf(str,"%[^.].%[^,],%s",str1,str2,str3);//删除某一个元素%[^(删除的元素)]删除的元素 printf("%s %s %s\n",str1,str2,str3); // str="ios&lt;android&gt;wp7"; sscanf(str,"%*[^&lt;]&lt;%[^&gt;]",str1);//省略&lt;之前的字符串 printf("%s\n%s",str,str1); //str1=android str="android iphone wp7"; sscanf(str,"%s %*s %s",str1,str2); //省略掉iPhone printf("%s\n%s\n%s",str,str1,str2); //str1=android str2=wp7&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[括号匹配问题]]></title>
    <url>%2F2019%2F03%2F19%2F%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文主要是对于链表的复习，同时也为下篇的小型计算器做准备.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;string.h&gt;#define EleType char//宏定义#define max 100typedef struct node//定义括号的链表形式&#123; EleType ch; struct node*next;&#125;Brack;//括号void init(Brack *&amp;L)//初始化栈&#123; L = (Brack*)malloc(sizeof(Brack)); L-&gt;next = NULL;&#125;bool StackEmpty(Brack *L)//判断栈空&#123; return (L-&gt;next == NULL) ? 1 : 0;&#125;void DestoryStack(Brack *L)//销毁栈&#123; Brack *p = L, *q = L-&gt;next; while (q != NULL) &#123; free(p); p = q; q = p-&gt;next; &#125; free(p);//因为删除完毕后还剩余L-&gt;next未删除&#125;void push(Brack *L,char ch)//入栈&#123; Brack *temp = (Brack*)malloc(sizeof(Brack));//头插法入栈 temp-&gt;ch = ch; temp-&gt;next = NULL; L-&gt;next = temp;&#125;void pop(Brack *L,char ch)//出栈&#123; if (L-&gt;next == NULL) &#123; return ; &#125; Brack *p = L-&gt;next;//新申请结点存储入链栈的元素 ch = p-&gt;ch; L-&gt;next = p-&gt;next; free(p);&#125;bool GetTop(Brack *L, char &amp;ch)//得到栈顶元素是否成功&#123; if (L-&gt;next == NULL) return false; ch = L-&gt;next-&gt;ch; return true;&#125;bool Match(char exp[], int n)//匹配算法&#123; int i = 0;char e; bool match = true; Brack *L;//定义结构体对象 init(L);//初始化结构体 while (i &lt; n&amp;&amp;match) &#123; if (exp[i] == '(')//如果是左括号的话入栈 push(L, exp[i]); else if(exp[i]==')') &#123; if (GetTop(L, e) == true)//在栈未空的前提下 &#123; if (e != '(')//进行继续判断 &#123; match = false; &#125; else pop(L, e); &#125; else//在向链栈中放入元素')'时,栈为空，一定不匹配， match = false; &#125; i++; &#125; if (!StackEmpty(L))//判断栈L是否为空，如果为空的话，说明左括号和右括号数量相等 &#123; match = false; &#125; DestoryStack(L);//破坏栈 return match; &#125;int main()&#123; char exp[max] = &#123; "()()" &#125;; if (Match(exp, strlen(exp))) &#123; printf("匹配\n"); &#125; else &#123; printf("不匹配\n"); &#125; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表的算法设计]]></title>
    <url>%2F2019%2F03%2F15%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[当学习完单链表后，仔细回忆回忆，单链表还是很容易掌握的，但是还是要仔细认真的品味。单链表可以看做是由若干个结点由指针指向后继结点一种表.结点是由数据域和指针域构成。真正有效的存储是数据域,指针域负责指向下一个结点存储的位置,所以它的存储密度都是小于1,而之前学习的顺序表存储密度都是1.那么如何定义结构体12345typedef struct node&#123; Eletype data;//数据域 struct node*next;//指针域&#125;node,*Node; 那么单链表具体可以做些什么操作哪? 初始化操作,主要是对于头结点来说的,头结点一般不存储数据 12345void initnNode(Node head)&#123; head=(Node)malloc(sizeof(node)); head-&gt;next=null;&#125; 插入结点操作,插入分为两种,头插法和尾插法 1234567891011121314151617void insertData(Node head,int data)&#123; Node temp=(Node)malloc(sizeof(node)); temp-&gt;data=data;# if 0 //头插法 temp-&gt;next=head-&gt;next; head-&gt;next=temp;//时间复杂度为O(1)#else//尾插法 Node p; p=head; while(p-&gt;next!=NULL)//时间复杂度为O(n)此处不能用p来进行判断,若p为尾结点的话也符合条件，但是进入循环后就不符合和会发生野指针的情况 &#123; p=p-&gt;next; &#125; p-&gt;next=temp; temp-&gt;next=NULL;&#125; 查找结点操作,由于单链表需要用指针进行移动,所以不能用二分法(假设存储的数据是有顺序的)进行查找 123456789101112131415161718192021void findData(Node head,int data)&#123; Node p; p=head; while(p!=NULL) &#123; if(p-&gt;data==data) &#123; printf("已找到数据"); break;//退出循环 &#125; else &#123; p=p-&gt;next; if(p==NULL) &#123; printf("未找到该数据"); &#125; &#125; &#125;&#125; 删除结点 12345678910111213141516171819void deleteData(Node head,int data)&#123; Node p; p=head; while(p!=NULL) &#123; Node temp; if(p-&gt;data==data) &#123; temp=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next; free(temp);//释放出删除的结点空间 &#125; else &#123; p=p-&gt;next; &#125; &#125;&#125; 删除单链表中的最大值结点 12345678910111213141516171819void delMaxNode(Node head)&#123; Node p=head-&gt;next; Node pre=head;//p和pre是同步运动的 Node maxp=p; Node maxpre=pre; which(p!=NULL) &#123; if(maxp-&gt;data&lt;p-&gt;data) &#123; maxp=p; maxpre=pre;//最大值的前驱 &#125; pre=p; p=p-&gt;next; &#125; maxpre-&gt;next=maxp-&gt;next; free(maxp);&#125; 结点有序递增 123456789101112131415161718void sort(Node head)&#123; Node p,pre,q; p=head-&gt;next-&gt;next;//p指向L的第二个数据结点 head-&gt;next-&gt;next=NULL;//构造只含一个数据结点的有序表 while(p!=NULL) &#123; q=p-&gt;next; pre=head; while(pre-&gt;next!=NULL&amp;&amp;pre-&gt;next-&gt;data&lt;p-&gt;data) &#123; pre=pre-&gt;next; &#125; p-&gt;next=pre-&gt;next; pre-&gt;next=p; p=q; &#125;&#125; 解释如下图]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于IDEA无法找到或无法加载主类]]></title>
    <url>%2F2019%2F03%2F15%2F%E5%85%B3%E4%BA%8EIDEA%E6%97%A0%E6%B3%95%E6%89%BE%E5%88%B0%E4%B8%BB%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[今天打开IDEA进行看视频写JAVA程序，却发现之前写的小程序却显示无法找到或无法加载主类，网上看了好多博客，最终找到解决我的问题的博客以下是大佬的文章博客地址qq_37889152主要有四种情况在IDEA的使用过程中，经常断掉服务或者重启服务一.错误: 找不到或者无法加载主类缓存问题：菜单-&gt;文件-&gt;invalidate Caches/Restart 选择Invalidate and Restart 或者只是invalidate ，清理掉缓存;然后重启IDEA。二.查看是否source Floders 有多个，只保留当前需要用的工程路径，点击P右边的删除即可(我遇到的就是这种情况)删除后然后查看是否能够运行。三. 上面不行的话查看第二种方式1.查看这里是否指定路径四.把配置文件删除，然后用导包重新配置1.2.3.到项目的绝对路径下删除配置文件4.然后重新导入5.一直下一步6.这里如果有多个，则需要选择需要的工程路径，只有一个直接next就ok]]></content>
      <categories>
        <category>JAVA修炼中</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类和对象的初步理解]]></title>
    <url>%2F2019%2F03%2F09%2F%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[带着表格思维学习JAVA 就拿二维表格来说表的结构组成对应的就是类，而一行数据（记录）对应的是对象.就好比你要去找对象，首先你心里肯定对对象有一定的要求。就比如长的好看的女生,其中含有两个标准，然后你根据这个标准在你们班里或者院里进行寻找，发现匹配到的女生有好多，其中的她们学习成绩有好的，也有差的，有会跳舞的，也有会摄影的。然后你需要统计统计该找那个作为追的对象.于是你有了下面的表格权衡再三你觉的第四个机会更大些，于是你开始了追爱之旅。其实这种只是简单的类与对象的例子，也就是我们数据库中学到的关系模型，类就好比与关系模式,对象就好比于元组。（个人见解）。]]></content>
      <categories>
        <category>JAVA修炼中</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优质线性表删除算法]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BC%98%E8%B4%A8%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[已知长度为N的线性表A采用顺序存储的结构，设计一个时间复杂度为O（n）,空间复杂度为O（1）的算法，该算法删除线性表中所有值为x的数据元素在我们不考虑复杂度的情况下当我们看到这个题时，往往映入脑海中的就是以下两种算法算法一：顺序查找，每删除一个x，后面所有的元素都向前进一位，然而这样的话会导致时间复杂度为O（N^2）算法二：新建一个链表进行存储，然而这样导致空间复杂度就变成O(n)下面的两种优质算法恰好符合上面的两个条件 算法一：设计遍历的过程将符合条件的数据重叠写在之前的位置,及k记录这组数据中不是x的数据的个数 算法二：设计计数器k来计算这组数据中重复的x的次数代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define max 100typedef struct node&#123; int data[max]; int lenth;&#125;SqList;void insert(SqList *&amp;L,int *arr,int size)//写入数据&#123; int i; L-&gt;lenth = size; for (i = 0; i &lt; size; i++) &#123; L-&gt;data[i] = arr[i]; &#125;&#125;void deleteData1(SqList *&amp;L, int x)&#123; int k = 0, i; for (i = 0; i &lt; L-&gt;lenth; i++) &#123; if (L-&gt;data[i] != x) &#123; L-&gt;data[k] = L-&gt;data[i]; k++; &#125; &#125; L-&gt;lenth = k;&#125;void deleteData2(SqList *&amp;L, int x)&#123; int k = 0,i; for (i = 0; i &lt; L-&gt;lenth; i++) &#123; if (L-&gt;data[i] == x) &#123; k++; &#125; else &#123; L-&gt;data[i - k] = L-&gt;data[i];//向左移动k个单位 &#125; &#125; L-&gt;lenth = L-&gt;lenth - k;&#125;void print(SqList *&amp;L)&#123; int i; for (i = 0; i &lt; L-&gt;lenth; i++) &#123; printf("%d ", L-&gt;data[i]); &#125;&#125;int main()&#123; SqList *L,*L1; L = (SqList*)malloc(sizeof(SqList)); L1= (SqList*)malloc(sizeof(SqList)); int arr[7] = &#123; 1,2,1,2,3,2,4 &#125;; int arr1[7] = &#123; 1,2,1,2,3,2,4 &#125;; printf("算法一："); insert(L, arr, 7); deleteData1(L, 2); print(L); printf("\n算法二："); insert(L1, arr1, 7); deleteData2(L1, 2); print(L1); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决每次布局都要重建CNAME问题]]></title>
    <url>%2F2019%2F03%2F07%2F%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[当我们经历万般千辛搭建好我们的博客后，我们终于开始了装 * 的时刻，但是我们会发现每次使用hexo deploy提交之后，再在我们的浏览器上登录的我们的域名却发现无法登陆，再登到我们的github上看发现CNAME没有了.重建之后又好了。 解决方案： 在blog/source目录下重建一个无后缀的CNAME文件，里面写上你的域名，就可以了。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表实现快速排列]]></title>
    <url>%2F2019%2F03%2F07%2F%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[本篇博客主要讲解如何使用单链表进行快速排列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct list//构建结构体&#123; int data; struct list*next;&#125;LIST,*PLIST;PLIST init()//结构体的初始化&#123; PLIST temp; temp = (PLIST)malloc(sizeof(LIST)); temp-&gt;next = NULL; return temp;&#125;void insert(PLIST head, int NewDate)//数据的插入&#123; //头插法 PLIST p= (PLIST)malloc(sizeof(LIST));//准备新结点 p-&gt;data = NewDate; //数据放进去#if 0 temp-&gt;next = head-&gt;next;//将head后面的连接到temp-&gt;next上面。同时head断了与后面的连接 head-&gt;next = temp;//将temp连接到head-&gt;next上连接起来#else //尾插法 PLIST temp = head;//head赋值给temp while (temp-&gt;next != NULL)//遍历head找到尾部 &#123; temp = temp-&gt;next; &#125; //找到了 就退出开始插入。 temp-&gt;next = p;//刚刚申请的结点 p-&gt;next = NULL;#endif&#125;void ScanData(PLIST head)&#123; printf("请输入数字\n"); for (int i = 0; i &lt; 5; i++) &#123; int n = 0; printf("&gt;"); scanf("%d", &amp;n); insert(head, n); &#125;&#125;void print(PLIST head)&#123; PLIST p = head-&gt;next; while (p!= NULL) &#123; printf("%d\t", p-&gt;data); p = p-&gt;next; &#125;&#125;void Sort(PLIST *head)//功能函数&#123; PLIST p, q;//定义指针 q = (*head)-&gt;next;//工作指针 p = (*head)-&gt;next;//基准 while (q-&gt;next != NULL) &#123; if (p-&gt;next-&gt;data &lt; p-&gt;data)//找到比基准小的数字 &#123; q = p-&gt;next;//将小于基准的位置找出来 p-&gt;next = p-&gt;next-&gt;next;//将该数字前后连起来 q-&gt;next = p; (*head)-&gt;next = q;//查到基准的前面 &#125; else &#123; p-&gt;next = p-&gt;next-&gt;next; &#125; q = q-&gt;next; &#125;&#125;int main()&#123; PLIST head; head = init(); ScanData(head); //print(head); Sort(&amp;head); print(head); getchar(); return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
