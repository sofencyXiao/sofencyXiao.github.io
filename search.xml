<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于IDEA无法找到或无法加载主类]]></title>
    <url>%2F2019%2F03%2F15%2F%E5%85%B3%E4%BA%8EIDEA%E6%97%A0%E6%B3%95%E6%89%BE%E5%88%B0%E4%B8%BB%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[今天打开IDEA进行看视频写JAVA程序，却发现之前写的小程序却显示无法找到或无法加载主类，网上看了好多博客，最终找到解决我的问题的博客以下是大佬的文章博客地址qq_37889152主要有三种情况一.查看是否source Floders 有多个，只保留当前需要用的工程路径，点击P右边的删除即可(我遇到的就是这种情况)删除后然后查看是否能够运行。二. 上面不行的话查看第二种方式1.查看这里是否指定路径三.把配置文件删除，然后用导包重新配置1.2.3.到项目的绝对路径下删除配置文件4.然后重新导入5.一直下一步6.这里如果有多个，则需要选择需要的工程路径，只有一个直接next就ok]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类和对象的初步理解]]></title>
    <url>%2F2019%2F03%2F09%2F%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[带着表格思维学习JAVA 就拿二维表格来说表的结构组成对应的就是类，而一行数据（记录）对应的是对象.就好比你要去找对象，首先你心里肯定对对象有一定的要求。就比如长的好看的女生,其中含有两个标准，然后你根据这个标准在你们班里或者院里进行寻找，发现匹配到的女生有好多，其中的她们学习成绩有好的，也有差的，有会跳舞的，也有会摄影的。然后你需要统计统计该找那个作为追的对象.于是你有了下面的表格权衡再三你觉的第四个机会更大些，于是你开始了追爱之旅。其实这种只是简单的类与对象的例子，也就是我们数据库中学到的关系模型，类就好比与关系模式,对象就好比于元组。（个人见解）。]]></content>
      <categories>
        <category>JAVA 修炼中</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优质线性表删除算法]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BC%98%E8%B4%A8%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[已知长度为N的线性表A采用顺序存储的结构，设计一个时间复杂度为O（n）,空间复杂度为O（1）的算法，该算法删除线性表中所有值为x的数据元素在我们不考虑复杂度的情况下当我们看到这个题时，往往映入脑海中的就是以下两种算法算法一：顺序查找，每删除一个x，后面所有的元素都向前进一位，然而这样的话会导致时间复杂度为O（N^2）算法二：新建一个链表进行存储，然而这样导致空间复杂度就变成O(n)下面的两种优质算法恰好符合上面的两个条件 算法一：设计遍历的过程将符合条件的数据重叠写在之前的位置,及k记录这组数据中不是x的数据的个数 算法二：设计计数器k来计算这组数据中重复的x的次数代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define max 100typedef struct node&#123; int data[max]; int lenth;&#125;SqList;void insert(SqList *&amp;L,int *arr,int size)//写入数据&#123; int i; L-&gt;lenth = size; for (i = 0; i &lt; size; i++) &#123; L-&gt;data[i] = arr[i]; &#125;&#125;void deleteData1(SqList *&amp;L, int x)&#123; int k = 0, i; for (i = 0; i &lt; L-&gt;lenth; i++) &#123; if (L-&gt;data[i] != x) &#123; L-&gt;data[k] = L-&gt;data[i]; k++; &#125; &#125; L-&gt;lenth = k;&#125;void deleteData2(SqList *&amp;L, int x)&#123; int k = 0,i; for (i = 0; i &lt; L-&gt;lenth; i++) &#123; if (L-&gt;data[i] == x) &#123; k++; &#125; else &#123; L-&gt;data[i - k] = L-&gt;data[i];//向左移动k个单位 &#125; &#125; L-&gt;lenth = L-&gt;lenth - k;&#125;void print(SqList *&amp;L)&#123; int i; for (i = 0; i &lt; L-&gt;lenth; i++) &#123; printf("%d ", L-&gt;data[i]); &#125;&#125;int main()&#123; SqList *L,*L1; L = (SqList*)malloc(sizeof(SqList)); L1= (SqList*)malloc(sizeof(SqList)); int arr[7] = &#123; 1,2,1,2,3,2,4 &#125;; int arr1[7] = &#123; 1,2,1,2,3,2,4 &#125;; printf("算法一："); insert(L, arr, 7); deleteData1(L, 2); print(L); printf("\n算法二："); insert(L1, arr1, 7); deleteData2(L1, 2); print(L1); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决每次布局都要重建CNAME问题]]></title>
    <url>%2F2019%2F03%2F07%2F%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[当我们经历万般千辛搭建好我们的博客后，我们终于开始了装 * 的时刻，但是我们会发现每次使用hexo deploy提交之后，再在我们的浏览器上登录的我们的域名却发现无法登陆，再登到我们的github上看发现CNAME没有了.重建之后又好了。 解决方案： 在blog/source目录下重建一个无后缀的CNAME文件，里面写上你的域名，就可以了。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表实现快速排列]]></title>
    <url>%2F2019%2F03%2F07%2F%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[本篇博客主要讲解如何使用单链表进行快速排列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct list//构建结构体&#123; int data; struct list*next;&#125;LIST,*PLIST;PLIST init()//结构体的初始化&#123; PLIST temp; temp = (PLIST)malloc(sizeof(LIST)); temp-&gt;next = NULL; return temp;&#125;void insert(PLIST head, int NewDate)//数据的插入&#123; //头插法 PLIST p= (PLIST)malloc(sizeof(LIST));//准备新结点 p-&gt;data = NewDate; //数据放进去#if 0 temp-&gt;next = head-&gt;next;//将head后面的连接到temp-&gt;next上面。同时head断了与后面的连接 head-&gt;next = temp;//将temp连接到head-&gt;next上连接起来#else //尾插法 PLIST temp = head;//head赋值给temp while (temp-&gt;next != NULL)//遍历head找到尾部 &#123; temp = temp-&gt;next; &#125; //找到了 就退出开始插入。 temp-&gt;next = p;//刚刚申请的结点 p-&gt;next = NULL;#endif&#125;void ScanData(PLIST head)&#123; printf("请输入数字\n"); for (int i = 0; i &lt; 5; i++) &#123; int n = 0; printf("&gt;"); scanf("%d", &amp;n); insert(head, n); &#125;&#125;void print(PLIST head)&#123; PLIST p = head-&gt;next; while (p!= NULL) &#123; printf("%d\t", p-&gt;data); p = p-&gt;next; &#125;&#125;void Sort(PLIST *head)//功能函数&#123; PLIST p, q;//定义指针 q = (*head)-&gt;next;//工作指针 p = (*head)-&gt;next;//基准 while (q-&gt;next != NULL) &#123; if (p-&gt;next-&gt;data &lt; p-&gt;data)//找到比基准小的数字 &#123; q = p-&gt;next;//将小于基准的位置找出来 p-&gt;next = p-&gt;next-&gt;next;//将该数字前后连起来 q-&gt;next = p; (*head)-&gt;next = q;//查到基准的前面 &#125; else &#123; p-&gt;next = p-&gt;next-&gt;next; &#125; q = q-&gt;next; &#125;&#125;int main()&#123; PLIST head; head = init(); ScanData(head); //print(head); Sort(&amp;head); print(head); getchar(); return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
