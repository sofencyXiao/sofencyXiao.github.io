<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[优质线性表删除算法]]></title>
    <url>%2F2019%2F03%2F09%2F%E4%BC%98%E8%B4%A8%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[已知长度为N的线性表A采用顺序存储的结构，设计一个时间复杂度为O（n）,空间复杂度为O（1）的算法，该算法删除线性表中所有值为x的数据元素在我们不考虑复杂度的情况下当我们看到这个题时，往往映入脑海中的就是以下两种算法算法一：顺序查找，每删除一个x，后面所有的元素都向前进一位，然而这样的话会导致时间复杂度为O（N^2）算法二：新建一个链表进行存储，然而这样导致空间复杂度就变成O(n)下面的两种优质算法恰好符合上面的两个条件 算法一：设计遍历的过程将符合条件的数据重叠写在之前的位置,及k记录这组数据中不是x的数据的个数 算法二：设计计数器k来计算这组数据中重复的x的次数代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define max 100typedef struct node&#123; int data[max]; int lenth;&#125;SqList;void insert(SqList *&amp;L,int *arr,int size)//写入数据&#123; int i; L-&gt;lenth = size; for (i = 0; i &lt; size; i++) &#123; L-&gt;data[i] = arr[i]; &#125;&#125;void deleteData1(SqList *&amp;L, int x)&#123; int k = 0, i; for (i = 0; i &lt; L-&gt;lenth; i++) &#123; if (L-&gt;data[i] != x) &#123; L-&gt;data[k] = L-&gt;data[i]; k++; &#125; &#125; L-&gt;lenth = k;&#125;void deleteData2(SqList *&amp;L, int x)&#123; int k = 0,i; for (i = 0; i &lt; L-&gt;lenth; i++) &#123; if (L-&gt;data[i] == x) &#123; k++; &#125; else &#123; L-&gt;data[i - k] = L-&gt;data[i];//向左移动k个单位 &#125; &#125; L-&gt;lenth = L-&gt;lenth - k;&#125;void print(SqList *&amp;L)&#123; int i; for (i = 0; i &lt; L-&gt;lenth; i++) &#123; printf("%d ", L-&gt;data[i]); &#125;&#125;int main()&#123; SqList *L,*L1; L = (SqList*)malloc(sizeof(SqList)); L1= (SqList*)malloc(sizeof(SqList)); int arr[7] = &#123; 1,2,1,2,3,2,4 &#125;; int arr1[7] = &#123; 1,2,1,2,3,2,4 &#125;; printf("算法一："); insert(L, arr, 7); deleteData1(L, 2); print(L); printf("\n算法二："); insert(L1, arr1, 7); deleteData2(L1, 2); print(L1); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决每次布局都要重建CNAME问题]]></title>
    <url>%2F2019%2F03%2F07%2F%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[当我们经历万般千辛搭建好我们的博客后，我们终于开始了装 * 的时刻，但是我们会发现每次使用hexo deploy提交之后，再在我们的浏览器上登录的我们的域名却发现无法登陆，再登到我们的github上看发现CNAME没有了.重建之后又好了。 解决方案： 在blog/source目录下重建一个无后缀的CNAME文件，里面写上你的域名，就可以了。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表实现快速排列]]></title>
    <url>%2F2019%2F03%2F07%2F%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[本篇博客主要讲解如何使用单链表进行快速排列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct list//构建结构体&#123; int data; struct list*next;&#125;LIST,*PLIST;PLIST init()//结构体的初始化&#123; PLIST temp; temp = (PLIST)malloc(sizeof(LIST)); temp-&gt;next = NULL; return temp;&#125;void insert(PLIST head, int NewDate)//数据的插入&#123; //头插法 PLIST p= (PLIST)malloc(sizeof(LIST));//准备新结点 p-&gt;data = NewDate; //数据放进去#if 0 temp-&gt;next = head-&gt;next;//将head后面的连接到temp-&gt;next上面。同时head断了与后面的连接 head-&gt;next = temp;//将temp连接到head-&gt;next上连接起来#else //尾插法 PLIST temp = head;//head赋值给temp while (temp-&gt;next != NULL)//遍历head找到尾部 &#123; temp = temp-&gt;next; &#125; //找到了 就退出开始插入。 temp-&gt;next = p;//刚刚申请的结点 p-&gt;next = NULL;#endif&#125;void ScanData(PLIST head)&#123; printf("请输入数字\n"); for (int i = 0; i &lt; 5; i++) &#123; int n = 0; printf("&gt;"); scanf("%d", &amp;n); insert(head, n); &#125;&#125;void print(PLIST head)&#123; PLIST p = head-&gt;next; while (p!= NULL) &#123; printf("%d\t", p-&gt;data); p = p-&gt;next; &#125;&#125;void Sort(PLIST *head)//功能函数&#123; PLIST p, q;//定义指针 q = (*head)-&gt;next;//工作指针 p = (*head)-&gt;next;//基准 while (q-&gt;next != NULL) &#123; if (p-&gt;next-&gt;data &lt; p-&gt;data)//找到比基准小的数字 &#123; q = p-&gt;next;//将小于基准的位置找出来 p-&gt;next = p-&gt;next-&gt;next;//将该数字前后连起来 q-&gt;next = p; (*head)-&gt;next = q;//查到基准的前面 &#125; else &#123; p-&gt;next = p-&gt;next-&gt;next; &#125; q = q-&gt;next; &#125;&#125;int main()&#123; PLIST head; head = init(); ScanData(head); //print(head); Sort(&amp;head); print(head); getchar(); return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
